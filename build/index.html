<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Build · Sensors for Restoration</title>
  <link rel="stylesheet" href="../style.css" />
</head>
<body>
  <header>
    <h1>Build</h1>
    <nav>
      <a href="../index.html">Home</a>
      <a href="index.html">Build</a>
      <a href="../updates.html">Updates</a>
      <a href="../forum.html">Forum</a>
      <a href="../about.html">About</a>
      <a href="../contact.html">Contact</a>
    </nav>
  </header>

  <div class="navbar navbar-fixed-top" style="z-index: -1;"></div>
  <div id="header"></div>

  <xmp id="strapcontent" style="display:none;"></xmp>

  <div class="build-layout">
    <aside id="toc" aria-label="Table of contents">
      <h3>Contents</h3>
      <ul></ul>
    </aside>
    <main id="content" class="container"></main>
  </div>

  <script>
  (async function(){
    const files = ['BOM.md','pin_table.md'];
    let md = '';
    for(const f of files){
      try{
        const r = await fetch(f);
        if(r.ok){ md += '\n\n' + await r.text(); }
        else { md += `\n\n<!-- Failed to load ${f}: ${r.status} -->`; }
      }catch(e){ md += `\n\n<!-- Error loading ${f}: ${e} -->`; }
    }
    const x = document.getElementById('strapcontent');
    x.innerText = md;

    // Load marked (lightweight markdown parser) from CDN instead of strapdown
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
    s.onload = function(){
      try{
        // Render markdown into the page
        const html = (typeof marked === 'function') ? marked(md) : x.innerText;
        const container = document.getElementById('content');
        container.innerHTML = html;

        // Build hierarchical TOC grouped by source file and heading level (h1-h3)
        const tocRoot = document.querySelector('#toc ul');
        tocRoot.innerHTML = '';

        // Parse headings per file from the raw markdown so we can group them by file
        const fileHeadings = [];
        const fileTexts = md.split(/\n\n(?=#)/g); // split when a new file's H1 starts
        for (let ft of fileTexts) {
          const hs = [];
          const re = /^#{1,3}\s+(.+)$/gm;
          let m;
          while ((m = re.exec(ft)) !== null) {
            const level = (m[0].match(/^#+/)[0] || '').length;
            hs.push({level, text: m[1].trim()});
          }
          fileHeadings.push(hs);
        }

        // Assign unique ids to rendered headings in DOM and build TOC entries grouped by file
        function slugify(s){ return s.toString().toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''); }
        const allRendered = container.querySelectorAll('h1,h2,h3');
        let renderIdx = 0;
        for (let fi = 0; fi < fileHeadings.length; fi++) {
          const hs = fileHeadings[fi];
          if (hs.length === 0) continue;
          // File label: use first H1 text if present, else filename
          const fileLabel = hs[0] && hs[0].level===1 ? hs[0].text : ('File ' + (fi+1));
          const fileLi = document.createElement('li');
          const fileA = document.createElement('strong');
          fileA.textContent = fileLabel;
          fileLi.appendChild(fileA);
          const subUl = document.createElement('ul');

          for (let hi = 0; hi < hs.length; hi++){
            const hinfo = hs[hi];
            const hnode = allRendered[renderIdx++];
            if(!hnode) continue;
            let id = slugify(hinfo.text);
            let uid = id; let c=1; while(document.getElementById(uid)){ uid = id + '-' + (c++); }
            hnode.id = uid;

            const li = document.createElement('li');
            li.style.marginLeft = (Math.max(0, hinfo.level-1) * 10) + 'px';
            const a = document.createElement('a');
            a.href = '#'+uid;
            a.textContent = hinfo.text;
            a.addEventListener('click', (ev)=>{ ev.preventDefault(); document.getElementById(uid).scrollIntoView({behavior:'smooth', block:'start'}); history.replaceState(null,'', '#'+uid); });
            li.appendChild(a);
            subUl.appendChild(li);
          }
          fileLi.appendChild(subUl);
          tocRoot.appendChild(fileLi);
        }

        // style tables
        const tables = container.getElementsByTagName('table');
        for(let i=0;i<tables.length;i++){
          tables[i].style.width='100%'; tables[i].style.borderCollapse='collapse'; tables[i].style.margin='12px 0';
          if(tables[i].querySelectorAll) Array.from(tables[i].querySelectorAll('th,td')).forEach(td=>{td.style.border='1px solid #cfd8c3'; td.style.padding='8px';});
        }
      }catch(e){ console.error('render error', e); }
    };
    document.body.appendChild(s);
  })();
  </script>

  <footer>© <span id="y"></span> Sensors for Restoration</footer>
  <script>document.getElementById('y').textContent = new Date().getFullYear();</script>
</body>
</html>
